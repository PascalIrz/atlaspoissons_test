---
title: "Macroécologie bassins"
author: "OFB"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  bookdown::html_document2:
    toc: true
    toc_float: true
#  bookdown::word_document2
always_allow_html: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message=F, warning = F)
```

# Chargement des packages et des données

```{r}
library(MASS) # keep MASS firts yo avoid function conflict with dplyr
library(tidyverse)
#library(sf)
#library(vegan)
library(corrplot)
library(factoextra)
library(FactoMineR)
library(mapview)
#library(aspe)


#source(file = "../R/lm_indices_env.R")
```


```{r}
#load(file = "../processed_data/data2.rda")
# load(file = '../processed_data/aspe.RData')
# load(file = "../processed_data/especes_a_supprimer.rda")
# load(file = "../processed_data/aspe_macroecologie_data.rda")
load(file = "../processed_data/carto_data2.rda")
```

# Cartographie des richesses par bassin

```{r}
bv_richesse <- bv_faune %>% 
  filter(statut == "Présent") %>% 
  group_by(code_exutoire) %>% 
  summarise(rsr = n_distinct(code_espece))

map_data <- bv_simp_geo %>% 
  right_join(bv_richesse) %>% 
  select(code_exutoire,
         toponyme,
         rsr)

mapview(map_data,
        zcol = "rsr")
```

# Explications de la richesse des bassins

## Assemblage des données

```{r}
bv_data <- bv_env %>% 
    mutate(surf_km2 = surf_m2 / 1e6,
           long_tp_km = long_tp_m / 1000) %>% 
    mutate_at(vars(starts_with("X_")), as.numeric) %>% 
  select(-surf_m2,
         -long_tp_m) %>% 
  left_join(bv_effort_prospection) %>% 
  left_join(bv_richesse) %>% 
  filter(rsr > 0)
```

## Distribution des variables explicatives

Les variables quantitatives

```{r}
bv_data %>% 
  select(code_exutoire,
         alt_moy:surf_km2) %>% 
  pivot_longer(cols = -code_exutoire) %>% 
  ggplot(aes(x = value)) +
    geom_density() +
    facet_wrap(~name, scales = "free") +
    scale_x_log10(labels = scales::label_comma())
```
Variables qualitatives

```{r}
bv_data %>% 
  select(code_exutoire,
         canal_conn,
         strahler_m) %>% 
  pivot_longer(cols = -code_exutoire) %>% 
  ggplot(aes(x = value)) +
    geom_bar() +
    facet_wrap(~name, scales = "free")
```

## Relations entre variables explicatives

On se limite aux variables quantitatives car d'une part la connexion à un canal est très rare et d'autre part le rang de strahler ne sera pas conservé car son information serait redondante avec celle des variabkes quantitatives.

```{r}
library("PerformanceAnalytics")
chart.Correlation(bv_data %>% select(alt_moy:surf_km2),
                  histogram = TRUE,
                  pch = 19)
```

Test en log-transformant.

```{r}
chart.Correlation(bv_data %>% select(alt_moy:surf_km2) %>% mutate_all(log10),
                  histogram = TRUE,
                  pch = 19)
```

Les distributons sont plus proches de la normale quand les variables "surf_km2", "prct_PE_CE" et "pte_tp_moy" sont log-transformées, donc on applique cette transformation.

```{r}
bv_data <- bv_data %>% 
  mutate(prct_PE_CE = ifelse(is.na(prct_PE_CE), 0, prct_PE_CE),
         prct_PE_CE = log(1 + prct_PE_CE)) %>% 
  mutate_at(vars(surf_km2, pte_tp_moy), log)
```

```{r}
acp <- bv_data %>% 
  select(code_exutoire,
         alt_moy:surf_km2) %>% 
  column_to_rownames("code_exutoire") %>% 
  FactoMineR::PCA(graph = FALSE)

factoextra::fviz_pca_var(acp, col.var = "contrib", gradient.col = c("pink", "purple", "blue"), repel = TRUE)
```

```{r}
matrice_cor <- cor(bv_data %>% 
  select(alt_moy:surf_km2) %>% 
    na.omit())

corrplot(matrice_cor)
```

*A affiner* : on retient les moyennes pour l'altitude, la pente et parc + les 2 variables pêu corrélées aux autres.

## Modélisation

```{r}
model_data <- bv_data %>% 
            filter(!str_detect(toponyme, "Vilaine"), # Vilaine
                   !str_detect(toponyme, "l'Aulne"), # Aulne
                   !str_detect(toponyme, "Blavet"), # Le blavet
                   code_exutoire != "exut_643") # Rance

mod <- lm(rsr ~ alt_moy +
            pente_moy +
            parc_moy +
            prct_PE_CE +
            prct_rpg +
            surf_km2 +
            X_centroid +
            n_inventaires #+
           # canal_conn
          ,
          data = model_data)

summary(mod)
```
```{r}
plot(mod)
```

```{r}
summary(stepAIC(mod))
```

