---
title: "Macroécologie au point"
author: "OFB"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  bookdown::html_document2:
    toc: true
    toc_float: true
#  bookdown::word_document2
always_allow_html: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message=F, warning = F)
```

# Chargement des packages et des données

```{r}
library(tidyverse)
library(sf)
library(vegan)
library(corrplot)
library(factoextra)
library(FactoMineR)
library(mapview)
library(aspe)
library(COGiter)

source(file = "../R/lm_indices_env.R")
```


```{r}
#load(file = "../processed_data/data2.rda")
load(file = '../processed_data/aspe.RData')
load(file = "../processed_data/especes_a_supprimer.rda")
load(file = "../processed_data/aspe_macroecologie_data.rda")
```


# Indices de biodiversité

Dans cette partie, pour éviter que certains points, échantillonnés à de multiples reprises, ne prennent une importance exagérée, on ne conserve que la dernière année de données pour chacun des points.

## Distribution des indices

NB Pielou n'est pas calculé sur les points monospécifiques car il a au dénominateur le log de la richesse.

```{r}
pt_indices_long %>% 
  ggplot(aes(x = value)) + 
  geom_density(fill = "darkgreen",
               alpha = 0.2) +
  scale_x_continuous(limits = c(0, NA)) +
  facet_wrap(~name, scales = "free")
```


## Cartographie des indices

```{r, fig.width = 5, fig.height = 12}
test <- aspe_pops_geo %>%
 # rename(code_point = pop_id) %>% 
  right_join(pt_indices_long) #%>% 
            #   mutate(code_point = as.integer(code_point)))

pal <- wesanderson::wes_palette("Zissou1", 100, type = "continuous")

bg <- COGiter::departements_metro_geo %>% 
  filter(DEP %in% c("22", "29", "35", "56"))

g <- purrr::map(.x = unique(test$name),
                .f = function(x) {
                            ggplot() +
                    geom_sf(data = bg) +
                    geom_sf(data = filter(test, name == x),
                                   aes(col = value)) +
                    ggtitle(x) +
                    scale_color_gradientn(colours = pal,
                                          name = "")
                })

g2 <- cowplot::plot_grid(plotlist = g,
                         ncol = 1)

g2
```

# Modélisation

## Examen des variables explicatives

```{r}
library("PerformanceAnalytics")
chart.Correlation(pt_indices %>% select(altitude:y_wgs84),
                  histogram = TRUE,
                  pch = 19)
```

Pour se rapprocher de distributions normales, on va log-transformer les variables à part les coordonnées.

```{r}
pt_indices <- pt_indices %>%
  mutate_at(vars(dist_source:pente, starts_with("temp")), log) %>% 
  mutate(altitude = log(1 + altitude))

chart.Correlation(pt_indices %>% select(altitude:y_wgs84),
                  histogram = TRUE,
                  pch = 19)
```

Les distributions sont beaucoup plus satisfaisantes. Les variables `dist_source`, `surf_bv` et `largeur` sont trop corrélées pour être utilisées telles quelles dans les modèles donc on va les regrouper en une variable synthétique par ACP.

## Construction de l'indice de taille du cours d'eau

```{r}
taille <- FactoMineR::PCA(pt_indices %>% select(dist_source, surf_bv, largeur))
taille <- taille$ind$coord[,1]
```

Ajout de la variable `taille` au dataframe.

```{r}
pt_indices <- pt_indices %>% 
  cbind(taille)
```

Vérification.

```{r}
cor(pt_indices %>% select(taille, dist_source, surf_bv, largeur))
```

# Modélisation

## Richesse spécifique

On construit un modèle avec l'ensemble des variables explicatives, puis on le simplifie par une procédure pas à pas au moyen de la fonction `stepAIC()` du package `MASS`.

### Modèle complet

```{r}
mod <- lm(richesse ~ altitude +
            taille +
            pente +
            temp_01 +
            temp_07 +
            x_wgs84 +
            y_wgs84,
          data = pt_indices)

summary(mod)
```

### Simplification

```{r, results='hide'}
mod2 <- MASS::stepAIC(mod)
```


```{r}
summary(mod2)
```

### Interprétation

On observe donc que les stations sont d'autant plus riches qu'elles sont :

- sur des cours d'eau grands, peu pentus, frais en hiver et chauds en été
- localisées au sud de l'aire étudiée

Bien que le paramètre de longidude `x_wgs84` ne soit pas retenu par la procédure de simplification, les deux paramètres de température correspondent à un gradient de longitude. En effet sur l'Ouest de la zone d'étude les hivers sont plus doux et les étés plus frais qu'à l'Est.

#### Vérifications graphiques

```{r}
plot(mod2)
```

## Autres indices

Sans aller autant dans le détail que pour la richesse spécifique on peut reproduire la démarche pour les autres indices (sans appliquer ici la `stepAIC`; on conserve toutes les variables explicatives).

```{r}
lm_indices_env(df = pt_indices,
               variables_dependantes = c("richesse", "shannon", "simpson", "pielou")) %>% 
  rownames_to_column("Variable explicative") %>% 
  flextable::flextable() %>% 
  flextable::set_table_properties(layout = "autofit", width = .9) %>% 
  flextable::theme_zebra()
```





